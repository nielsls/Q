' X = xor(A,B)Private Function fn_xor(args As Variant) As Variant    Utils_AssertArgsCount args, 2, 2    Dim out, r As Long, c As Long, i As Long, j As Long    Dim arg1_r As Long, arg1_c As Long, arg2_r As Long, arg2_c As Long    Utils_SetupBinaryOperation args, out, r, c, arg1_r, arg1_c, arg2_r, arg2_c, False    For i = 1 To r        For j = 1 To c            out(i, j) = CBool(args(1)(MIN(i, arg1_r), MIN(j, arg1_c))) _                    Xor CBool(args(2)(MIN(i, arg2_r), MIN(j, arg2_c)))        Next j    Next i    fn_xor = outEnd Function
' X = tick2ret(A)' X = tick2ret(A,dim)'' Returns simple percentage returnsPrivate Function fn_tick2ret(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    Dim x As Long: x = Utils_CalcDimDirection(args, 2)    Dim r: ReDim r(UBound(args(1), 1) - (1 - x), UBound(args(1), 2) - x)    Dim i As Long, j As Long    For i = 1 To UBound(r, 1)        For j = 1 To UBound(r, 2)            r(i, j) = args(1)(i + (1 - x), j + x) / args(1)(i, j) - 1        Next j    Next i    fn_tick2ret = rEnd Function
' X = ret2tick(A)' X = ret2tick(A,dim)'' Creates timeseries from simple percentage returns.' New base is 100Private Function fn_ret2tick(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    Dim x As Long: x = Utils_CalcDimDirection(args, 2)    Dim r: ReDim r(UBound(args(1), 1) + (1 - x), UBound(args(1), 2) + x)    Dim i As Long, j As Long    For j = 1 To UBound(r, 2 - x)        r(1 * (1 - x) + j * x, j * (1 - x) + 1 * x) = 100    Next j    For i = 2 - x To UBound(r, 1)        For j = 1 + x To UBound(r, 2)            r(i, j) = r(i - (1 - x), j - x) * (1 + args(1)(i - (1 - x), j - x))        Next j    Next i    fn_ret2tick = rEnd Function
' B = cumsum(A)' B = cumsum(A,dim)'' B = cumsum(A) returns the cumulative sum along different dimensions of' an array. If A is a vector, cumsum(A) returns a vector containing the' cumulative sum of the elements of A. If A is a matrix, cumsum(A)' returns a matrix the same size as A containing the cumulative sums for' each column of A.'' B = cumsum(A,dim) returns the cumulative sum of the elements along the' dimension of A specified by scalar dim. For example, cumsum(A,1) works' along the first dimension (the columns); cumsum(A,2) works along the '' second dimension (the rows).Private Function fn_cumsum(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_cumsum = Utils_ToMatrix(0): Exit Function    Dim i As Long, j As Long, x As Long    x = Utils_CalcDimDirection(args)    For i = 2 - x To UBound(args(1), 1)        For j = 1 + x To UBound(args(1), 2)            args(1)(i, j) = args(1)(i, j) + args(1)(i - (1 - x), j - x)        Next j    Next i    fn_cumsum = args(1)End Function
' B = cumprod(A)' B = cumprod(A,dim)'' B = cumprod(A) returns the cumulative product along different dimensions of' an array. If A is a vector, cumsum(A) returns a vector containing the' cumulative product of the elements of A. If A is a matrix, cumprod(A)' returns a matrix the same size as A containing the cumulative products for' each column of A.'' B = cumprod(A,dim) returns the cumulative product of the elements along the' dimension of A specified by scalar dim. For example, cumprod(A,1) works' along the first dimension (the columns); cumprod(A,2) works along the' second dimension (the rows).Private Function fn_cumprod(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_cumprod = Utils_ToMatrix(1): Exit Function    Dim i As Long, j As Long, x As Long    x = Utils_CalcDimDirection(args)    For i = 2 - x To UBound(args(1), 1)        For j = 1 + x To UBound(args(1), 2)            args(1)(i, j) = args(1)(i, j) * args(1)(i - (1 - x), j - x)        Next j    Next i    fn_cumprod = args(1)End Function
' B = cummax(A)' B = cummax(A,dim)Private Function fn_cummax(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_cummax = Utils_ToMatrix(DOUBLE_MIN): Exit Function    Dim i As Long, j As Long, x As Long    x = Utils_CalcDimDirection(args)    For i = 2 - x To UBound(args(1), 1)        For j = 1 + x To UBound(args(1), 2)            args(1)(i, j) = MAX(args(1)(i, j), args(1)(i - (1 - x), j - x))        Next j    Next i    fn_cummax = args(1)End Function
' B = cummin(A)' B = cummin(A,dim)Private Function fn_cummin(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_cummin = Utils_ToMatrix(DOUBLE_MAX): Exit Function    Dim i As Long, j As Long, x As Long    x = Utils_CalcDimDirection(args)    For i = 2 - x To UBound(args(1), 1)        For j = 1 + x To UBound(args(1), 2)            args(1)(i, j) = MIN(args(1)(i, j), args(1)(i - (1 - x), j - x))        Next j    Next i    fn_cummin = args(1)End Function
' X = std(A)' X = std(A,dim)'' X = std(A) returns the standard deviation of the elements of A' along the first array dimension whose size does not equal 1.'' X = std(A,dim) calculates the elements of A along dimension dim.' The dim input is a positive integer scalar.Private Function fn_std(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then Exit Function    Dim x As Long, i As Long, out As Variant    Utils_SetupReducedDimOperation args, out, x    With WorksheetFunction        For i = 1 To UBound(out, 2 - x)            out(x * i + (1 - x), (1 - x) * i + x) = .StDev(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_std = outEnd Function
' X = var(A)' X = var(A,dim)'' X = var(A) returns the variance of the elements of A' along the first array dimension whose size does not equal 1.'' X = var(A,dim) calculates the elements of A along dimension dim.' The dim input is a positive integer scalar.Private Function fn_var(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then Exit Function    Dim x As Long, i As Long, out As Variant    Utils_SetupReducedDimOperation args, out, x    With WorksheetFunction        For i = 1 To UBound(out, 2 - x)            out(x * i + (1 - x), (1 - x) * i + x) = .Var(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_var = outEnd Function
' X = corr(A)'' X = corr(A) returns a correlation matrix for the columns of A.Private Function fn_corr(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 1    If IsEmpty(args(1)) Then Exit Function    Utils_Assert UBound(args(1), 1) > 1, "too few rows"    Dim c As Long: c = UBound(args(1), 2)    Dim out: ReDim out(c, c)    Dim i As Long, j As Long    With WorksheetFunction        For i = 1 To c            For j = i To c                out(i, j) = .Correl(.index(args(1), 0, i), .index(args(1), 0, j))                out(j, i) = out(i, j)            Next j        Next i    End With    fn_corr = outEnd Function
' X = cov(A)'' X = cov(A) returns a covariance matrix for the columns of A.Private Function fn_cov(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 1    If IsEmpty(args(1)) Then Exit Function    Dim c As Long: c = UBound(args(1), 2)    Dim out: ReDim out(c, c)    Dim i As Long, j As Long    With WorksheetFunction        For i = 1 To c            For j = i To c                out(i, j) = .Covar(.index(args(1), 0, i), .index(args(1), 0, j))                out(j, i) = out(i, j)            Next j        Next i    End With    fn_cov = outEnd Function
' X = all(A)' X = all(A,dim)'' all(...) tests if all elements in A evaluates to true.' In practice, all() is a natural extension of the logical AND' operator.Private Function fn_all(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_all = Utils_ToMatrix(True): Exit Function    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .And(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_all = rEnd Function
' X = any(A)' X = any(A,dim)'' any(...) tests if any of the elements in A evaluates to true.' In practice, any() is a natural extension of the logical OR' operator.Private Function fn_any(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_any = Utils_ToMatrix(False): Exit Function    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .Or(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_any = rEnd Function
' X = sum(A)' X = sum(A,dim)'' X = sum(A) returns the sum of the elements of A along the' first array dimension whose size does not equal 1.'' X = sum(A,dim) sums the elements of A along dimension dim.' The dim input is a positive integer scalar.Private Function fn_sum(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_sum = Utils_ToMatrix(0): Exit Function    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .Sum(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_sum = rEnd Function
' X = prod(A)' X = prod(A,dim)'' X = prod(A) returns the product of the elements of A' along the first array dimension whose size does not equal 1.'' X = prod(A,dim) multiplies the elements of A along dimension dim.' The dim input is a positive integer scalar.Private Function fn_prod(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_prod = Utils_ToMatrix(1): Exit Function    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .Product(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_prod = rEnd Function
' X = mean(A)' X = mean(A,dim)Private Function fn_mean(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .Average(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_mean = rEnd Function
' X = median(A)' X = median(A,dim)Private Function fn_median(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .Median(.index(args(1), x * i, (1 - x) * i))        Next i    End With    fn_median = rEnd Function
' X = prctile(A,p)' X = prctile(A,p,dim)'' p must be a number between 0 and 1Private Function fn_prctile(args As Variant) As Variant    Utils_AssertArgsCount args, 2, 3    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x, 3    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .Percentile(.index(args(1), x * i, (1 - x) * i), args(2)(1, 1))        Next i    End With    fn_prctile = rEnd Function
' X = percentrank(A,x)' X = percentrank(A,x,dim)'' The inverse of the prctilePrivate Function fn_percentrank(args As Variant) As Variant    Utils_AssertArgsCount args, 2, 3    Dim x As Long, i As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x, 3    With WorksheetFunction        For i = 1 To UBound(r, 2 - x)            r(x * i + (1 - x), (1 - x) * i + x) = .PercentRank(.index(args(1), x * i, (1 - x) * i), args(2)(1, 1))        Next i    End With    fn_percentrank = rEnd Function
' X = count(A)' X = count(A,dim)'' X = count(A) counts the number of elements in A which do not evaluate to falsePrivate Function fn_count(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 2    If IsEmpty(args(1)) Then fn_count = 0: Exit Function    Dim x As Long, i As Long, j As Long, r As Variant    Utils_SetupReducedDimOperation args, r, x    For i = 1 To UBound(args(1), 1)        For j = 1 To UBound(args(1), 2)            r(i * x + (1 - x), j * (1 - x) + x) _                = r(i * x + (1 - x), j * (1 - x) + x) - CBool(args(1)(i, j))        Next j    Next i    fn_count = rEnd Function
' M = max(A)' M = max(A,[],dim)' M = max(A,B)Private Function fn_max(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 3    Dim r As Variant, x As Long, y As Long, i As Long    If UBound(args) = 1 Or UBound(args) = 3 Then        If UBound(args) = 3 Then Utils_Assert IsEmpty(args(2)), "2nd argument must be empty matrix, []."        If IsEmpty(args(1)) Then fn_max = Utils_ToMatrix(DOUBLE_MIN): Exit Function        Utils_SetupReducedDimOperation args, r, x, 3        With WorksheetFunction            For i = 1 To UBound(r, 2 - x)                r(x * i + (1 - x), (1 - x) * i + x) _                    = .MAX(.index(args(1), x * i, (1 - x) * i))            Next i        End With    Else        Dim r1 As Long, c1 As Long        Dim r2 As Long, c2 As Long        Utils_Size args(1), r1, c1        Utils_Size args(2), r2, c2        Utils_Assert (r1 = 1 And c1 = 1) Or (r2 = 1 And c2 = 1) Or (r1 = r2 And c1 = c2), "max(): Wrong dimensions."        ReDim r(MAX(r1, r2), MAX(c1, c2))        For x = 1 To UBound(r, 1)            For y = 1 To UBound(r, 2)                r(x, y) = MAX(args(1)(MIN(x, r1), MIN(y, c1)), args(2)(MIN(x, r2), MIN(y, c2)))            Next y        Next x    End If    fn_max = rEnd Function
' M = min(A)' M = min(A,[],dim)' M = min(A,B)Private Function fn_min(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 3    Dim r As Variant, x As Long, y As Long, i As Long    If UBound(args) = 1 Or UBound(args) = 3 Then        If UBound(args) = 3 Then Utils_Assert IsEmpty(args(2)), "2nd argument must be empty matrix, []."        If IsEmpty(args(1)) Then fn_min = Utils_ToMatrix(DOUBLE_MAX): Exit Function        Utils_SetupReducedDimOperation args, r, x, 3        With WorksheetFunction            For i = 1 To UBound(r, 2 - x)                r(x * i + (1 - x), (1 - x) * i + x) _                    = .MIN(.index(args(1), x * i, (1 - x) * i))            Next i        End With    Else        Dim r1 As Long, c1 As Long        Dim r2 As Long, c2 As Long        Utils_Size args(1), r1, c1        Utils_Size args(2), r2, c2        Utils_Assert (r1 = 1 And c1 = 1) Or (r2 = 1 And c2 = 1) Or (r1 = r2 And c1 = c2), "min: bad dimensions."        ReDim r(MAX(r1, r2), MAX(c1, c2))        For x = 1 To UBound(r, 1)            For y = 1 To UBound(r, 2)                r(x, y) = MIN(args(1)(MIN(x, r1), MIN(y, c1)), args(2)(MIN(x, r2), MIN(y, c2)))            Next y        Next x    End If    fn_min = rEnd Function
' X = size(A)'' X = size(A) returns a 1-by-2 vector with the number of rows and columns in A.Private Function fn_size(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 1    Dim out: ReDim out(1, 2)    Utils_Size args(1), out(1, 1), out(1, 2)    fn_size = outEnd Function
' X = diag(A)'' X = diag(A) returns a matrix with A in the diagonal if A is a vector,' or a column vector with the diagonal of A if A is a matrix.Private Function fn_diag(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 1    Dim rows As Long, cols As Long, r As Variant, i As Long    Utils_Size args(1), rows, cols    If Utils_IsVectorShape(rows, cols) Then        r = fn_repmat(Array(0, rows * cols, rows * cols))        For i = 1 To UBound(r, 1)            r(i, i) = args(1)(MIN(i, rows), MIN(i, cols))        Next i    Else        ReDim r(MIN(rows, cols), 1)        For i = 1 To UBound(r, 1)            r(i, 1) = args(1)(i, i)        Next i    End If    fn_diag = rEnd Function
' X = rand' X = rand(n)' X = rand(n,m)' X = rand([n m])'' rand(...) returns pseudorandom values drawn from the standard' uniform distribution on the open interval (0,1)Private Function fn_rand(args As Variant) As Variant    Utils_AssertArgsCount args, 0, 2    Dim n As Long, m As Long    Utils_GetSizeFromArgs args, n, m, 1    If n < 1 Or m < 1 Then Exit Function    Dim out: ReDim out(n, m)    For n = 1 To UBound(out, 1)        For m = 1 To UBound(out, 2)            out(n, m) = Rnd        Next m    Next n    fn_rand = outEnd Function
' X = randi(imax)' X = randi(imax,n)' X = randi(imax,n,m)' X = randi(imax,[n m])' X = randi([imin imax], ...)'' randi(...) returns pseudorandom integer values drawn from the' discrete uniform distribution on the interval [1, imax] or' [imin, imax].Private Function fn_randi(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 3    Dim imin As Long, imax As Long, n As Long, m As Long    Utils_GetSizeFromArgs args, n, m    If n < 1 Or m < 1 Then Exit Function    If Utils_Numel(args(1)) = 1 Then        imin = 1        imax = args(1)    Else        imin = args(1)(1, 1)        imax = args(1)(MIN(2, UBound(args(1), 1)), MIN(2, UBound(args(1), 2)))    End If    Dim out: ReDim out(n, m)    For n = 1 To UBound(out, 1)        For m = 1 To UBound(out, 2)            out(n, m) = CLng(Rnd * (imax - imin)) + imin        Next m    Next n    fn_randi = outEnd Function
' X = randn' X = randn(n)' X = randn(n,m)' X = randn([n m])'' randn(...) returns pseudorandom values drawn from the standard' normal distribution with mean 0 and variance 1.Private Function fn_randn(args As Variant) As Variant    Utils_AssertArgsCount args, 0, 2    Dim n As Long, m As Long    Utils_GetSizeFromArgs args, n, m, 1    If n < 1 Or m < 1 Then Exit Function    Dim r: ReDim r(n, m)    Dim p(2) As Double, tmp As Double, cached As Boolean    For n = 1 To UBound(r, 1)        For m = 1 To UBound(r, 2)            If Not cached Then                Do                    p(1) = 2 * Rnd - 1                    p(2) = 2 * Rnd - 1                    tmp = p(1) * p(1) + p(2) * p(2)                Loop Until tmp <= 1                tmp = Sqr(-2 * Log(tmp) / tmp)                p(1) = p(1) * tmp                p(2) = p(2) * tmp            End If            cached = Not cached            r(n, m) = p(2 + cached)        Next m    Next n    fn_randn = rEnd Function
' X = normcdf(A)Private Function fn_normcdf(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 1    Dim r As Long, c As Long, i As Long, j As Long    Utils_Size args(1), r, c    With WorksheetFunction        For i = 1 To r            For j = 1 To c                args(1)(i, j) = .NormSDist(args(1)(i, j))            Next j        Next i    End With    fn_normcdf = args(1)End Function
' X = repmat(A,n)' X = repmat(A,n,m)' X = repmat(A,[n m])'' X = repmat(A,n) creates a large matrix X consisting of an n-by-n tiling of A.' X = repmat(A,n,m) creates a large matrix X consisting of an n-by-m tiling of A.' X = repmat(A,[n m]) creates a large matrix X consisting of an n-by-m tiling of A.Private Function fn_repmat(args As Variant) As Variant    Dim out, r As Long, c As Long, n As Long, m As Long, i As Long, j As Long    Utils_AssertArgsCount args, 2, 3    Utils_GetSizeFromArgs args, n, m    Utils_Size args(1), r, c    If r * n < 1 Or c * m < 1 Then Exit Function    ReDim out(r * n, c * m)    For n = 0 To n - 1        For m = 0 To m - 1            For i = 1 To r                For j = 1 To c                    out(n * r + i, m * c + j) = args(1)(i, j)                Next j            Next i        Next m    Next n    fn_repmat = outEnd Function
' B = reshape(A,n,m)' B = reshape(A,[],m)' B = reshape(A,n,[])'' B = reshape(A,n,m) returns the n-by-m matrix B whose elements are taken' column-wise from A. An error results if A does not have n*m elements.' Either n or m can be the empty matrix [] in which case the length of the' dimension is calculated automatically.Private Function fn_reshape(args As Variant) As Variant    Utils_AssertArgsCount args, 3, 3    Dim rows As Long, cols As Long, idx As Long    Dim r_i As Long, r_j As Long, arg_i As Long, arg_j As Long    Utils_Size args(1), rows, cols    If IsEmpty(args(2)) Then        args(3) = args(3)(1, 1)        If args(3) = 0 Then Exit Function        Utils_Assert rows * cols Mod args(3) = 0, "reshape: number of elements not evenly divisible by m"        args(2) = rows * cols / args(3)    ElseIf IsEmpty(args(3)) Then        args(2) = args(2)(1, 1)        If args(2) = 0 Then Exit Function        Utils_Assert rows * cols Mod args(2) = 0, "reshape: number of elements not evenly divisible by n"        args(3) = rows * cols / args(2)    Else        args(2) = args(2)(1, 1)        args(3) = args(3)(1, 1)        Utils_Assert rows * cols = args(2) * args(3), "reshape: number of elements is not equal to n*m"    End If    Utils_Assert args(2) >= 0 And args(3) >= 0, "new size must be non-negative"    If args(2) = 0 And args(3) = 0 Then Exit Function    Dim r: ReDim r(args(2), args(3))    For idx = 1 To rows * cols        Utils_Ind2Sub rows, idx, arg_i, arg_j        Utils_Ind2Sub CLng(args(2)), idx, r_i, r_j        r(r_i, r_j) = args(1)(arg_i, arg_j)    Next idx    fn_reshape = rEnd Function
' X = tostring(A)'' tostring(A) converts all entries of A into stringsPrivate Function fn_tostring(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 1    Dim r As Long, c As Long, i As Long, j As Long    Utils_Size args(1), r, c    For i = 1 To r        For j = 1 To c            args(1)(i, j) = args(1)(i, j) & ""        Next j    Next i    fn_tostring = args(1)End Function
' Z = if(B,X,Y)'' Z = if(B,X,Y) returns X if B evaluates to true; otherwise Y.' Note: X is only evaluated if B is true and Y is only evaluated if B is falsePrivate Function fn_if(args As Variant) As Variant    Utils_AssertArgsCount args, 3, 3    args(1) = calc_tree(args(1))    If IsEmpty(args(1)) Then        fn_if = calc_tree(args(3))    Else        fn_if = calc_tree(args(3 + CLng(CBool(args(1)(1, 1)))))    End IfEnd Function
' X = iferror(A,B)'' X = iferror(A,B) returns A if the evaluation of A does not result in a error;' otherwise, B is returned.Private Function fn_iferror(args As Variant) As Variant    Utils_AssertArgsCount args, 2, 2    On Error GoTo ErrorHandler:    fn_iferror = calc_tree(args(1))    Exit FunctionErrorHandler:    fn_iferror = calc_tree(args(2))End Function
' Y = diff(X)' Y = diff(X,n)' Y = diff(X,n,dim)Private Function fn_diff(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 3    If IsEmpty(args(1)) Then Exit Function    Dim x As Long: x = Utils_CalcDimDirection(args, 3)    If UBound(args(1), 1 + x) < 2 Then Exit Function    Dim i As Long, j As Long    Dim r: ReDim r(UBound(args(1), 1) - (1 - x), UBound(args(1), 2) - x)    For i = 2 - x To UBound(args(1), 1)        For j = 1 + x To UBound(args(1), 2)            r(i - (1 - x), j - x) = args(1)(i, j) - args(1)(i - (1 - x), j - x)        Next j    Next i    fn_diff = r    Dim n As Long: n = Utils_GetOptionalScalarArg(args, 2, 1)    If n > 1 Then fn_diff = fn_diff(Array(r, n - 1, 1 + x))End Function
' B = unique(A)'' B = unique(A) returns a column vector with all the unique elements of A.' The values of B are in sorted order.Private Function fn_unique(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 1    Dim numel As Long, i As Long, counter As Long, save    numel = Utils_Numel(args(1))    If numel < 1 Then Exit Function    args(1) = fn_reshape(Array(args(1), Empty, Utils_ToMatrix(1)))    args(1) = fn_sort(Array(args(1)))    ReDim save(1 To numel - 1)    counter = 1    For i = 1 To UBound(save)        save(i) = (0 <> Utils_Compare(args(1)(i, 1), args(1)(i + 1, 1)))        counter = counter - CLng(save(i))    Next i    Dim r: ReDim r(1 To counter, 1)    r(1, 1) = args(1)(1, 1)    counter = 2    For i = 1 To UBound(save)        If save(i) Then            r(counter, 1) = args(1)(i + 1, 1)            counter = counter + 1        End If    Next i    fn_unique = rEnd Function
' B = sort(A)' B = sort(A,dim)' B = sort(...,"descend")' B = sort(...,"indices")'' sort() sorts the entries in each row or column.'' Flags:' "descend":  Sort descending' "indices":  Return sorted indices instead of valuesPrivate Function fn_sort(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 4        ' Get all input parameters    Dim sortRows As Boolean, ascend As Boolean, returnIndices As Boolean    sortRows = (1 = Utils_CalcDimDirection(args))    ascend = Not Utils_IsFlagSet(args, "descend")    returnIndices = Utils_IsFlagSet(args, "indices")        ' Transpose input matrix if rows must be sorted    If sortRows Then        args(1) = WorksheetFunction.Transpose(args(1))        Utils_Conform args(1)    End If        ' Create an equal-sized array containing indices    ' Initially, the indices are just 1,2,3,...,n and    ' then the sorting will be done on these indices.    Dim rows As Long, cols As Long, i As Long, j As Long    Utils_Size args(1), rows, cols    Dim indices: ReDim indices(1 To rows, 1 To cols)    For i = 1 To rows        For j = 1 To cols            indices(i, j) = i        Next j    Next i        ' Do the actual sorting of each column    For j = 1 To cols        Utils_QuickSortCol args(1), indices, 1, rows, j, ascend    Next j        ' Return the sorted indices if that was specified;    ' otherwise build and return a matrix with the sorted values    If returnIndices Then        fn_sort = indices    Else        Dim r: ReDim r(1 To rows, 1 To cols)        For i = 1 To rows            For j = 1 To cols                r(i, j) = args(1)(indices(i, j), j)            Next j        Next i        fn_sort = r    End If        ' Remember to "transpose back" if we sorted the rows    If sortRows Then fn_sort = WorksheetFunction.Transpose(fn_sort)    Utils_Conform fn_sortEnd Function
' Implementation of the quick-sort algorithm - is a helper for fn_sort()' Sorts on columns by swapping indices.' No actual swapping of values in the original matrix is done.'' It sorts the column "col" in the range from "first" to "last"Private Function Utils_QuickSortCol(arr As Variant, indices As Variant, first As Long, last As Long, col As Long, ascend As Boolean)    If first >= last Then Exit Function    Dim tmp As Variant    Dim pivot As Variant: pivot = arr(indices(first, col), col)    Dim left As Long: left = first    Dim right As Long: right = last    Dim ascendprefix As Long: ascendprefix = -1 - 2 * Sgn(ascend)    While left <= right        While ascendprefix * Utils_Compare(arr(indices(left, col), col), pivot) < 0            left = left + 1        Wend        While ascendprefix * Utils_Compare(pivot, arr(indices(right, col), col)) < 0            right = right - 1        Wend        If left <= right Then            tmp = indices(left, col)            indices(left, col) = indices(right, col)            indices(right, col) = tmp            left = left + 1            right = right - 1        End If    Wend    Utils_QuickSortCol arr, indices, first, right, col, ascend    Utils_QuickSortCol arr, indices, left, last, col, ascendEnd Function
' Called from Utils_QuickSortCol. Compares numerics and strings.Private Function Utils_Compare(arg1 As Variant, arg2 As Variant) As Variant    If IsNumeric(arg1) Then        If IsNumeric(arg2) Then            Utils_Compare = arg1 - arg2        Else            Utils_Compare = -1        End If    Else        If IsNumeric(arg2) Then            Utils_Compare = 1        Else            Utils_Compare = StrComp(CStr(arg1), CStr(arg2))        End If    End IfEnd Function
' X = arrayfun(func,A1,...,An)'' arrayfun(...) calls the in-cell Excel function with name <func> and passes elements from' A1 to An, where n is the number of inputs to func.' A1 to An must all be scalars or matrices with the same sizePrivate Function fn_arrayfun(args As Variant) As Variant    Utils_AssertArgsCount args, 2, 100    Utils_Assert TypeName(args(1)) = "String", "apply: 1st argument must be an Excel function name."    Dim i As Long, r1 As Long, c1 As Long, r2 As Long, c2 As Long    r1 = -1: c1 = -1    For i = 2 To Utils_Stack_Size(args)        Utils_Size args(i), r2, c2        Utils_Assert (r1 < 0 And c1 < 0) Or (r2 = 1 And c2 = 1) Or (r1 = r2 And c1 = c2) Or ((r1 = 1 Or r1 = r2) And c2 = 1) Or (r2 = 1 And (c1 = 1 Or c1 = c2)), "apply(): Wrong input sizes."        r1 = MAX(r1, r2): c1 = MAX(c1, c2)    Next i    Dim v, r: ReDim r(r1, c1)    For r1 = 1 To UBound(r, 1)        For c1 = 1 To UBound(r, 2)            v = Empty            For i = 2 To Utils_Stack_Size(args)                Utils_Size args(i), r2, c2                Utils_Stack_Push args(i)(MIN(r1, r2), MIN(c1, c2)), v            Next i            r(r1, c1) = Evaluate(args(1) & "(" & Join(v, ",") & ")")        Next c1    Next r1    fn_arrayfun = rEnd Function
' B = join(A)' B = join(A,joiner)' B = join(A,joiner,dim)'' B = concat(...) concatenates the elements of A along the first' dimension whose size does not equal 1.Private Function fn_join(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 3    Dim i As Long, j As Long, x As Long, r_i As Long, r_j As Long, joiner As String    x = Utils_CalcDimDirection(args, 3)    joiner = Utils_GetOptionalScalarArg(args, 2, "")    Dim r: ReDim r(x * UBound(args(1), 1) + (1 - x), (1 - x) * UBound(args(1), 2) + x)    For i = 1 To UBound(args(1), 1)        For j = 1 To UBound(args(1), 2)            r_i = x * i + (1 - x)            r_j = (1 - x) * j + x            If (1 - x) * i + x * j = 1 Then                r(r_i, r_j) = args(1)(i, j)            Else                r(r_i, r_j) = r(r_i, r_j) & joiner & args(1)(i, j)            End If        Next j    Next i    fn_join = rEnd Function
' B = fn_expand(A)' B = fn_expand(A,n)' B = fn_expand(A,,m)' B = fn_expand(A,n,m)'' expand(A) returns the matrix beginning in cell A and expanding down and to the right' as far as there are contiguous non-empty cells.' Set n or m to specifically fix the number of rows or columns.' If n <= 0 or m <= 0, expand() will return the empty matrix.Private Function fn_expand(args As Variant) As Variant    Utils_AssertArgsCount args, 1, 3    Utils_Assert _        args(1)(1) = "eval_variable" And TypeName(arguments(args(1)(2))) = "Range", _        "expand(): 1st argument must be a cell"    Dim cell As Range: Set cell = arguments(args(1)(2))    Dim rows As Variant: If UBound(args) > 1 Then rows = calc_tree(args(2))    Dim cols As Variant: If UBound(args) > 2 Then cols = calc_tree(args(3))    If IsEmpty(rows) Then        If IsEmpty(cell.Offset(1, 0)) Then            rows = 1        Else            rows = cell.End(xlDown).Row - cell.Row + 1        End If    Else        rows = rows(1, 1)        If rows <= 0 Then Exit Function    End If    If IsEmpty(cols) Then        If IsEmpty(cell.Offset(0, 1)) Then            cols = 1        Else            cols = cell.End(xlToRight).Column - cell.Column + 1        End If    Else        cols = cols(1, 1)        If cols <= 0 Then Exit Function    End If    fn_expand = cell.Resize(rows, cols)    Utils_Conform fn_expandEnd Function
Private Function fn_e(args As Variant) As Variant    Utils_AssertArgsCount args, 0, 0    fn_e = Utils_ToMatrix(Exp(1))End Function
Private Function fn_pi(args As Variant) As Variant    Utils_AssertArgsCount args, 0, 0    fn_pi = Utils_ToMatrix(WorksheetFunction.Pi())End Function
' v = version'' Returns a string with the current version of the Q library.Private Function fn_version(args As Variant) As Variant    Utils_AssertArgsCount args, 0, 0    fn_version = Utils_ToMatrix(VERSION)End Function
